generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                       String                    @id @default(cuid())
  nickname                 String?
  image                    String?
  name                     String
  role                     UserRole                  @default(CLIENT)
  email                    String                    @unique
  emailVerified            DateTime?
  emailVerificationExpires DateTime?
  emailVerificationToken   String?
  phone                    String?
  password                 String?
  resetPasswordExpires     DateTime?
  resetPasswordToken       String?
  inviteCode               String?                   @unique // Código único para convites
  isActive                 Boolean                   @default(true)
  deletedAt                DateTime?
  deletedById              String?
  updatedById              String?
  createdAt                DateTime                  @default(now())
  updatedAt                DateTime                  @updatedAt
  servicesProvided         Appointment[]             @relation("BarberAppointments")
  appointments             Appointment[]
  serviceHistory           ServiceHistory[]
  promotions               UserPromotion[]
  vouchers                 Voucher[]
  accounts                 account[]
  friendshipsInitiated     Friendship[]              @relation("UserFriendships")
  friendshipsReceived      Friendship[]              @relation("FriendFriendships")
  friendRequestsSent       FriendRequest[]           @relation("RequestSender")
  friendRequestsReceived   FriendRequest[]           @relation("RequestReceiver")
  notifications            Notification[]
  conversationParticipants ConversationParticipant[]
  messages                 Message[]
  deletedBy                User?                     @relation("UserDeletionActor", fields: [deletedById], references: [id], onDelete: SetNull)
  updatedBy                User?                     @relation("UserUpdateActor", fields: [updatedById], references: [id], onDelete: SetNull)
  deletedUsers             User[]                    @relation("UserDeletionActor")
  updatedUsers             User[]                    @relation("UserUpdateActor")

  @@index([deletedAt])
  @@index([role, deletedAt])
}

model account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Service {
  id                String             @id @default(cuid())
  name              String
  description       String?
  duration          Int
  price             Decimal            @db.Decimal(10, 2)
  active            Boolean            @default(true)
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  appointments      Appointment[]
  promotionServices PromotionService[]
  serviceHistory    ServiceHistory[]
  vouchers          Voucher[]
}

model Appointment {
  id                 String            @id @default(cuid())
  date               DateTime
  status             AppointmentStatus @default(SCHEDULED)
  notes              String?
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt
  userId             String
  barberId           String
  serviceId          String
  serviceHistoryId   String?
  voucherId          String?
  appliedPromotionId String?
  appliedPromotion   Promotion?        @relation(fields: [appliedPromotionId], references: [id])
  barber             User              @relation("BarberAppointments", fields: [barberId], references: [id])
  serviceHistory     ServiceHistory?   @relation(fields: [serviceHistoryId], references: [id])
  service            Service           @relation(fields: [serviceId], references: [id])
  user               User              @relation(fields: [userId], references: [id])
  voucher            Voucher?          @relation(fields: [voucherId], references: [id])
}

model ServiceHistory {
  id           String        @id @default(cuid())
  completedAt  DateTime      @default(now())
  notes        String?
  finalPrice   Decimal       @db.Decimal(10, 2)
  rating       Int?
  feedback     String?
  images       String[]      @default([]) // Array de URLs das imagens
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  userId       String
  serviceId    String
  appointments Appointment[]
  service      Service       @relation(fields: [serviceId], references: [id])
  user         User          @relation(fields: [userId], references: [id])
}

model Voucher {
  id           String        @id @default(cuid())
  code         String        @unique
  type         VoucherType
  value        Decimal       @db.Decimal(10, 2)
  minServices  Int           @default(1)
  validFrom    DateTime      @default(now())
  validUntil   DateTime?
  status       VoucherStatus @default(ACTIVE)
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  userId       String
  serviceId    String?
  appointments Appointment[]
  service      Service?      @relation(fields: [serviceId], references: [id])
  user         User          @relation(fields: [userId], references: [id])
}

model Promotion {
  id                String             @id @default(cuid())
  name              String
  description       String?
  type              PromotionType
  value             Decimal            @db.Decimal(10, 2)
  validFrom         DateTime           @default(now())
  validUntil        DateTime?
  isGlobal          Boolean            @default(false)
  minFrequency      Int?
  active            Boolean            @default(true)
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  appointments      Appointment[]
  servicePromotions PromotionService[]
  userPromotions    UserPromotion[]
}

model UserPromotion {
  id          String    @id @default(cuid())
  createdAt   DateTime  @default(now())
  userId      String
  promotionId String
  promotion   Promotion @relation(fields: [promotionId], references: [id])
  user        User      @relation(fields: [userId], references: [id])

  @@unique([userId, promotionId])
}

model PromotionService {
  id          String    @id @default(cuid())
  createdAt   DateTime  @default(now())
  promotionId String
  serviceId   String
  promotion   Promotion @relation(fields: [promotionId], references: [id])
  service     Service   @relation(fields: [serviceId], references: [id])

  @@unique([promotionId, serviceId])
}

model Friendship {
  id        String           @id @default(cuid())
  status    FriendshipStatus @default(ACCEPTED)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  userId    String
  friendId  String
  user      User             @relation("UserFriendships", fields: [userId], references: [id], onDelete: Cascade)
  friend    User             @relation("FriendFriendships", fields: [friendId], references: [id], onDelete: Cascade)

  @@unique([userId, friendId])
  @@index([userId])
  @@index([friendId])
}

model FriendRequest {
  id         String              @id @default(cuid())
  status     FriendRequestStatus @default(PENDING)
  createdAt  DateTime            @default(now())
  updatedAt  DateTime            @updatedAt
  senderId   String
  receiverId String
  sender     User                @relation("RequestSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver   User                @relation("RequestReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId])
  @@index([receiverId])
  @@index([senderId])
}

model Notification {
  id        String           @id @default(cuid())
  type      NotificationType
  title     String
  message   String
  read      Boolean          @default(false)
  userId    String
  relatedId String?
  metadata  Json?
  createdAt DateTime         @default(now())
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, read])
  @@index([createdAt])
}

model Conversation {
  id            String                    @id @default(cuid())
  createdAt     DateTime                  @default(now())
  updatedAt     DateTime                  @updatedAt
  lastMessageAt DateTime?
  participants  ConversationParticipant[]
  messages      Message[]

  @@index([lastMessageAt])
}

model ConversationParticipant {
  id             String       @id @default(cuid())
  conversationId String
  userId         String
  lastReadAt     DateTime?
  createdAt      DateTime     @default(now())
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([userId])
}

model Message {
  id             String       @id @default(cuid())
  content        String       @db.Text
  conversationId String
  senderId       String
  isRead         Boolean      @default(false)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender         User         @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@index([conversationId, createdAt])
  @@index([senderId])
}

enum UserRole {
  CLIENT
  BARBER
  ADMIN
}

enum AppointmentStatus {
  SCHEDULED
  CONFIRMED
  COMPLETED
  CANCELLED
  NO_SHOW
}

enum VoucherStatus {
  ACTIVE
  USED
  EXPIRED
}

enum VoucherType {
  FREE_SERVICE
  DISCOUNT_PERCENTAGE
  DISCOUNT_FIXED
  CASHBACK
}

enum PromotionType {
  DISCOUNT_PERCENTAGE
  DISCOUNT_FIXED
  FREE_SERVICE
  CASHBACK
  LOYALTY_BONUS
}

enum FriendshipStatus {
  ACCEPTED
  BLOCKED
}

enum FriendRequestStatus {
  PENDING
  ACCEPTED
  REJECTED
  CANCELLED
}

enum NotificationType {
  FRIEND_REQUEST_RECEIVED
  FRIEND_REQUEST_ACCEPTED
  FRIEND_REQUEST_REJECTED
  FRIEND_INVITE_USED
}
